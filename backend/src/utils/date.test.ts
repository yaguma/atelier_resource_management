import { describe, test, expect } from 'vitest';
import { formatDate, formatDateISO, formatDateShort } from './date';

describe('日付フォーマット関数', () => {
  describe('formatDate', () => {
    // 【テスト目的】: formatDate関数が正しく日付をフォーマットできることを確認する
    // 【テスト内容】: Dateオブジェクトをデフォルトフォーマットでフォーマットする機能をテストする
    // 【期待される動作】: 日付が "YYYY-MM-DD HH:mm:ss" 形式でフォーマットされる
    // 🔴 信頼性レベル: 一般的な日付フォーマット機能のベストプラクティス
    test('TC-DATE-001: formatDate関数が正しく日付をフォーマットできること', () => {
      // 【テストデータ準備】: 一般的な日時を表すDateオブジェクトを用意
      // 【初期条件設定】: 2025年1月15日 10時30分45秒のDateオブジェクトを作成
      const date = new Date(2025, 0, 15, 10, 30, 45);

      // 【実際の処理実行】: formatDate関数を呼び出す
      // 【処理内容】: Dateオブジェクトをデフォルトフォーマットでフォーマットする
      const result = formatDate(date);

      // 【結果検証】: フォーマットされた日付文字列が期待値と一致することを確認
      // 【期待値確認】: デフォルトフォーマット "YYYY-MM-DD HH:mm:ss" に従う
      expect(result).toBe('2025-01-15 10:30:45'); // 【確認内容】: フォーマット文字列が正しく適用されることを確認 🔴
    });

    // 【テスト目的】: formatDate関数がカスタムフォーマット文字列に対応できることを確認する
    // 【テスト内容】: カスタムフォーマット文字列を指定してフォーマットする機能をテストする
    // 【期待される動作】: 指定されたフォーマット文字列に従ってフォーマットされる
    // 🔴 信頼性レベル: 一般的な日付フォーマット機能のベストプラクティス
    test('TC-DATE-002: formatDate関数がカスタムフォーマット文字列に対応できること', () => {
      // 【テストデータ準備】: 一般的な日時を表すDateオブジェクトとカスタムフォーマット文字列を用意
      // 【初期条件設定】: 2025年1月15日 10時30分45秒のDateオブジェクトを作成
      const date = new Date(2025, 0, 15, 10, 30, 45);
      const format = 'YYYY/MM/DD';

      // 【実際の処理実行】: formatDate関数をカスタムフォーマットで呼び出す
      // 【処理内容】: Dateオブジェクトをカスタムフォーマットでフォーマットする
      const result = formatDate(date, format);

      // 【結果検証】: フォーマットされた日付文字列が期待値と一致することを確認
      // 【期待値確認】: カスタムフォーマット "YYYY/MM/DD" に従う
      expect(result).toBe('2025/01/15'); // 【確認内容】: フォーマット文字列が正しく解釈されることを確認 🔴
    });

    // 【テスト目的】: 文字列形式の日付を正しくフォーマットできることを確認する
    // 【テスト内容】: 文字列形式の日付をDateオブジェクトに変換してフォーマットする機能をテストする
    // 【期待される動作】: 文字列形式の日付が正しくパースされてフォーマットされる
    // 🔴 信頼性レベル: 一般的な日付フォーマット機能のベストプラクティス
    test('TC-DATE-005: 文字列形式の日付のフォーマット', () => {
      // 【テストデータ準備】: ISO 8601形式の日付文字列を用意
      // 【初期条件設定】: ISO 8601形式の日付文字列を作成
      const dateString = '2025-01-15T10:30:45Z';

      // 【実際の処理実行】: formatDate関数を文字列で呼び出す
      // 【処理内容】: 文字列形式の日付をDateオブジェクトに変換してフォーマットする
      const result = formatDate(dateString);

      // 【結果検証】: フォーマットされた日付文字列が期待値と一致することを確認
      // 【期待値確認】: 文字列が正しくDateオブジェクトに変換されること
      expect(result).toBeTruthy(); // 【確認内容】: 文字列が正しくパースされることを確認 🔴
      expect(typeof result).toBe('string'); // 【確認内容】: 結果が文字列であることを確認 🔴
    });

    // 【テスト目的】: 数値形式（タイムスタンプ）の日付を正しくフォーマットできることを確認する
    // 【テスト内容】: 数値形式（タイムスタンプ）の日付をDateオブジェクトに変換してフォーマットする機能をテストする
    // 【期待される動作】: タイムスタンプが正しくDateオブジェクトに変換されてフォーマットされる
    // 🔴 信頼性レベル: 一般的な日付フォーマット機能のベストプラクティス
    test('TC-DATE-006: 数値形式（タイムスタンプ）の日付のフォーマット', () => {
      // 【テストデータ準備】: Unixタイムスタンプ（ミリ秒）を用意
      // 【初期条件設定】: 2025-01-15 10:30:45のタイムスタンプを作成
      const timestamp = 1736934645000;

      // 【実際の処理実行】: formatDate関数をタイムスタンプで呼び出す
      // 【処理内容】: タイムスタンプをDateオブジェクトに変換してフォーマットする
      const result = formatDate(timestamp);

      // 【結果検証】: フォーマットされた日付文字列が期待値と一致することを確認
      // 【期待値確認】: タイムスタンプが正しくDateオブジェクトに変換されること
      expect(result).toBeTruthy(); // 【確認内容】: タイムスタンプが正しく変換されることを確認 🔴
      expect(typeof result).toBe('string'); // 【確認内容】: 結果が文字列であることを確認 🔴
    });

    // 【テスト目的】: nullが渡された場合、適切にエラーを処理できることを確認する
    // 【テスト内容】: null値が渡された場合のエラーハンドリングをテストする
    // 【期待される動作】: エラーをスローするか、デフォルト値を返す
    // 🔴 信頼性レベル: 一般的なエラーハンドリングのベストプラクティス
    test('TC-DATE-101: nullが渡された場合の処理', () => {
      // 【テストデータ準備】: null値を用意
      // 【初期条件設定】: null値を設定
      const date = null as unknown as Date;

      // 【実際の処理実行】: formatDate関数をnullで呼び出す
      // 【処理内容】: null値が渡された場合の処理を確認
      // 【結果検証】: エラーをスローするか、デフォルト値を返すことを確認
      // 【期待値確認】: システムがクラッシュしないこと
      expect(() => formatDate(date)).toThrow(); // 【確認内容】: エラーをスローするか、適切に処理されることを確認 🔴
    });

    // 【テスト目的】: 無効な日付文字列が渡された場合、適切にエラーを処理できることを確認する
    // 【テスト内容】: パースできない無効な日付文字列が渡された場合のエラーハンドリングをテストする
    // 【期待される動作】: エラーをスローするか、デフォルト値を返す
    // 🔴 信頼性レベル: 一般的なエラーハンドリングのベストプラクティス
    test('TC-DATE-103: 無効な日付文字列が渡された場合の処理', () => {
      // 【テストデータ準備】: パースできない無効な日付文字列を用意
      // 【初期条件設定】: 無効な日付文字列を設定
      const invalidDateString = 'invalid-date-string';

      // 【実際の処理実行】: formatDate関数を無効な文字列で呼び出す
      // 【処理内容】: 無効な日付文字列が渡された場合の処理を確認
      // 【結果検証】: エラーをスローするか、デフォルト値を返すことを確認
      // 【期待値確認】: システムがクラッシュしないこと
      expect(() => formatDate(invalidDateString)).toThrow(); // 【確認内容】: エラーをスローするか、適切に処理されることを確認 🔴
    });
  });

  describe('formatDateISO', () => {
    // 【テスト目的】: formatDateISO関数がISO 8601形式でフォーマットできることを確認する
    // 【テスト内容】: DateオブジェクトをISO 8601形式でフォーマットする機能をテストする
    // 【期待される動作】: 日付がISO 8601形式（"YYYY-MM-DDTHH:mm:ss.sssZ"）でフォーマットされる
    // 🔴 信頼性レベル: ISO 8601標準に基づく
    test('TC-DATE-003: formatDateISO関数がISO 8601形式でフォーマットできること', () => {
      // 【テストデータ準備】: 一般的な日時を表すDateオブジェクトを用意
      // 【初期条件設定】: 2025年1月15日 10時30分45秒のDateオブジェクトを作成
      const date = new Date(2025, 0, 15, 10, 30, 45);

      // 【実際の処理実行】: formatDateISO関数を呼び出す
      // 【処理内容】: DateオブジェクトをISO 8601形式でフォーマットする
      const result = formatDateISO(date);

      // 【結果検証】: フォーマットされた日付文字列がISO 8601形式であることを確認
      // 【期待値確認】: ISO 8601標準に準拠していること
      expect(result).toMatch(/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/); // 【確認内容】: ISO 8601形式であることを確認 🔴
    });
  });

  describe('formatDateShort', () => {
    // 【テスト目的】: formatDateShort関数が短い形式でフォーマットできることを確認する
    // 【テスト内容】: Dateオブジェクトを短い形式（YYYY-MM-DD）でフォーマットする機能をテストする
    // 【期待される動作】: 日付が "YYYY-MM-DD" 形式でフォーマットされる
    // 🔴 信頼性レベル: 一般的な日付フォーマット機能のベストプラクティス
    test('TC-DATE-004: formatDateShort関数が短い形式でフォーマットできること', () => {
      // 【テストデータ準備】: 一般的な日時を表すDateオブジェクトを用意
      // 【初期条件設定】: 2025年1月15日 10時30分45秒のDateオブジェクトを作成
      const date = new Date(2025, 0, 15, 10, 30, 45);

      // 【実際の処理実行】: formatDateShort関数を呼び出す
      // 【処理内容】: Dateオブジェクトを短い形式でフォーマットする
      const result = formatDateShort(date);

      // 【結果検証】: フォーマットされた日付文字列が期待値と一致することを確認
      // 【期待値確認】: 短い形式 "YYYY-MM-DD" に従う
      expect(result).toBe('2025-01-15'); // 【確認内容】: 時刻部分が除外されることを確認 🔴
    });
  });
});

