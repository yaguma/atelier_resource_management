# TDDテストケース: Prismaスキーマ定義（Cardテーブル）

## タスク情報

- **タスクID**: TASK-0012
- **GitHub Issue**: #39
- **機能名**: Prismaスキーマ定義（Cardテーブル）
- **実装タイプ**: TDD
- **推定工数**: 1.5時間

## 開発言語・フレームワーク

🔵 **信頼性レベル: 青信号** - 既存の技術スタックから直接導出

- **プログラミング言語**: TypeScript 5.6.3
  - **言語選択の理由**: 既存のバックエンドプロジェクトでTypeScriptを使用しているため
  - **テストに適した機能**: 型安全性により、スキーマ定義の型チェックが可能
- **ORM**: Prisma 5.22.0
  - **フレームワーク選択の理由**: 既存のプロジェクトでPrismaを使用しているため
  - **テスト実行環境**: Prisma CLIを使用してスキーマの検証を行う

## テストケース分類

### 1. 正常系テストケース（基本的な動作）

#### TC-001: Prismaスキーマの型チェック

- **テスト名**: Prismaスキーマの構文検証
  - **何をテストするか**: Prismaスキーマファイルの構文が正しく、型チェックが通ることを確認
  - **期待される動作**: `prisma validate`コマンドが正常に完了し、エラーが発生しない
- **入力値**: `backend/prisma/schema.prisma`ファイルにCardモデルが定義されている
  - **入力データの意味**: PrismaスキーマファイルにCardモデルが正しく定義されている状態
- **期待される結果**: 
  - `prisma validate`コマンドが正常に完了（exit code 0）
  - エラーメッセージが出力されない
  - 警告メッセージが出力されない
  - **期待結果の理由**: Prismaスキーマの構文が正しければ、validateコマンドは正常に完了する
- **テストの目的**: スキーマ定義の構文正確性を確認
  - **確認ポイント**: Prismaスキーマの構文エラーがないことを確認
- 🔵 **信頼性レベル: 青信号** - Prisma公式ドキュメントに基づく標準的な検証方法

#### TC-002: Prisma Client生成の確認

- **テスト名**: Prisma Client生成の成功確認
  - **何をテストするか**: Prisma Clientが正常に生成され、Card型が利用可能になることを確認
  - **期待される動作**: `prisma generate`コマンドが正常に完了し、`@prisma/client`からCard型がインポート可能
- **入力値**: `backend/prisma/schema.prisma`ファイルにCardモデルが定義されている
  - **入力データの意味**: PrismaスキーマファイルにCardモデルが正しく定義されている状態
- **期待される結果**: 
  - `prisma generate`コマンドが正常に完了（exit code 0）
  - `node_modules/.prisma/client`ディレクトリに生成されたファイルが存在する
  - TypeScriptの型定義ファイル（`.d.ts`）にCard型が定義されている
  - **期待結果の理由**: Prisma Clientが正常に生成されれば、Card型が利用可能になる
- **テストの目的**: Prisma Client生成の成功を確認
  - **確認ポイント**: Card型が正しく生成されていることを確認
- 🔵 **信頼性レベル: 青信号** - Prisma公式ドキュメントに基づく標準的な検証方法

#### TC-003: Cardモデルのフィールド定義確認

- **テスト名**: Cardモデルの全フィールドが正しく定義されていることを確認
  - **何をテストするか**: Cardモデルに必要なすべてのフィールドが定義されていることを確認
  - **期待される動作**: 要件定義書に記載されたすべてのフィールドがPrismaスキーマに定義されている
- **入力値**: 要件定義書に記載されたフィールド一覧
  - **入力データの意味**: 要件定義書（card-schema-requirements.md）に記載されたフィールド定義
- **期待される結果**: 
  - 必須フィールド: `id`, `name`, `description`, `cardType`, `attribute`, `stabilityValue`, `energyCost`, `createdAt`, `updatedAt`が定義されている
  - オプショナルフィールド: `reactionEffect`, `imageUrl`, `rarity`, `evolutionFromId`, `deletedAt`が定義されている
  - リレーションフィールド: `evolutionFrom`, `evolutionTo`が定義されている
  - **期待結果の理由**: 要件定義書に記載されたすべてのフィールドが定義されていれば、要件を満たしている
- **テストの目的**: フィールド定義の完全性を確認
  - **確認ポイント**: すべての必須フィールドとオプショナルフィールドが定義されていることを確認
- 🔵 **信頼性レベル: 青信号** - 要件定義書から直接導出

#### TC-004: ENUM型の定義確認

- **テスト名**: CardTypeとRarityのENUM型が正しく定義されていることを確認
  - **何をテストするか**: Cardモデルで使用するENUM型（CardType, Rarity）が正しく定義されていることを確認
  - **期待される動作**: ENUM型がPrismaスキーマに定義され、Cardモデルで参照可能
- **入力値**: 要件定義書に記載されたENUM型定義
  - **入力データの意味**: 要件定義書に記載されたCardTypeとRarityのENUM型定義
- **期待される結果**: 
  - `CardType` ENUMが定義され、値が`MATERIAL`, `OPERATION`, `CATALYST`, `KNOWLEDGE`, `SPECIAL`, `ARTIFACT`である
  - `Rarity` ENUMが定義され、値が`COMMON`, `UNCOMMON`, `RARE`, `EPIC`, `LEGENDARY`である
  - Cardモデルの`cardType`フィールドが`CardType`型を参照している
  - Cardモデルの`rarity`フィールドが`Rarity?`型を参照している
  - **期待結果の理由**: ENUM型が正しく定義されていれば、Cardモデルで使用可能になる
- **テストの目的**: ENUM型定義の正確性を確認
  - **確認ポイント**: ENUM型の値が要件定義書と一致していることを確認
- 🔵 **信頼性レベル: 青信号** - 要件定義書と設計文書から直接導出

#### TC-005: インデックス定義の確認

- **テスト名**: Cardモデルに適切なインデックスが定義されていることを確認
  - **何をテストするか**: Cardモデルに必要なインデックスがすべて定義されていることを確認
  - **期待される動作**: 要件定義書に記載されたインデックスがPrismaスキーマに定義されている
- **入力値**: 要件定義書に記載されたインデックス一覧
  - **入力データの意味**: 要件定義書に記載されたインデックス定義
- **期待される結果**: 
  - `@@index([name])`が定義されている
  - `@@index([cardType])`が定義されている
  - `@@index([rarity])`が定義されている
  - `@@index([energyCost])`が定義されている
  - `@@index([evolutionFromId])`が定義されている
  - `@@index([deletedAt])`が定義されている
  - **期待結果の理由**: インデックスが定義されていれば、クエリパフォーマンスが向上する
- **テストの目的**: インデックス定義の完全性を確認
  - **確認ポイント**: すべてのインデックスが定義されていることを確認
- 🔴 **信頼性レベル: 赤信号** - 一般的なデータベース設計のベストプラクティスから推測

#### TC-006: テーブル名マッピングの確認

- **テスト名**: Cardモデルが`cards`テーブルにマッピングされていることを確認
  - **何をテストするか**: `@@map("cards")`ディレクティブが正しく設定されていることを確認
  - **期待される動作**: PrismaスキーマのCardモデルがデータベースの`cards`テーブルにマッピングされる
- **入力値**: 設計文書に記載されたテーブル名`cards`
  - **入力データの意味**: 設計文書（database-schema.sql）に記載されたテーブル名
- **期待される結果**: 
  - Cardモデルに`@@map("cards")`ディレクティブが設定されている
  - **期待結果の理由**: テーブル名が正しくマッピングされていれば、データベースとの整合性が保たれる
- **テストの目的**: テーブル名マッピングの正確性を確認
  - **確認ポイント**: `@@map("cards")`ディレクティブが設定されていることを確認
- 🔵 **信頼性レベル: 青信号** - 設計文書から直接導出

### 2. 異常系テストケース（エラーハンドリング）

#### TC-007: 構文エラーの検出

- **テスト名**: Prismaスキーマの構文エラーが検出されることを確認
  - **エラーケースの概要**: Prismaスキーマファイルに構文エラーがある場合、validateコマンドがエラーを検出する
  - **エラー処理の重要性**: 構文エラーを早期に検出することで、開発効率が向上する
- **入力値**: 構文エラーを含むPrismaスキーマファイル（例: 閉じ括弧の欠落、型の不一致）
  - **不正な理由**: Prismaスキーマの構文規則に違反している
  - **実際の発生シナリオ**: タイプミスやコピペミスにより構文エラーが発生する可能性がある
- **期待される結果**: 
  - `prisma validate`コマンドがエラーを返す（exit code 1）
  - エラーメッセージが出力される
  - エラーメッセージに構文エラーの位置が示される
  - **エラーメッセージの内容**: ユーザーにとって分かりやすいエラーメッセージが表示される
  - **システムの安全性**: エラー時にシステムが安全な状態を保てる（データベースへの影響なし）
- **テストの目的**: 構文エラー検出機能の確認
  - **品質保証の観点**: 構文エラーを早期に検出することで、品質の高いスキーマ定義を維持できる
- 🔵 **信頼性レベル: 青信号** - Prisma公式ドキュメントに基づく標準的な動作

#### TC-008: 型不一致エラーの検出

- **テスト名**: Prismaスキーマの型不一致エラーが検出されることを確認
  - **エラーケースの概要**: ENUM型が定義されていない状態でCardモデルがENUM型を参照している場合、エラーが検出される
  - **エラー処理の重要性**: 型不一致を早期に検出することで、実行時エラーを防ぐ
- **入力値**: CardType ENUMが定義されていない状態でCardモデルの`cardType`フィールドが`CardType`型を参照している
  - **不正な理由**: 参照先のENUM型が存在しないため、型不一致が発生する
  - **実際の発生シナリオ**: 依存タスクTASK-0011が未完了の状態で実装を進めた場合に発生する可能性がある
- **期待される結果**: 
  - `prisma validate`コマンドがエラーを返す（exit code 1）
  - エラーメッセージに「CardType is not defined」などの型不一致エラーが表示される
  - **エラーメッセージの内容**: ユーザーにとって分かりやすいエラーメッセージが表示される
  - **システムの安全性**: エラー時にシステムが安全な状態を保てる（データベースへの影響なし）
- **テストの目的**: 型不一致エラー検出機能の確認
  - **品質保証の観点**: 型不一致を早期に検出することで、型安全性を維持できる
- 🔵 **信頼性レベル: 青信号** - Prisma公式ドキュメントに基づく標準的な動作

### 3. 境界値テストケース（最小値、最大値、null等）

#### TC-009: 文字列長制約の確認

- **テスト名**: 文字列フィールドの長さ制約が正しく設定されていることを確認
  - **境界値の意味**: 文字列フィールドの最大長が正しく設定されていれば、データ整合性が保たれる
  - **境界値での動作保証**: 最大長を超えるデータがデータベースに保存されないことを保証する
- **入力値**: 要件定義書に記載された文字列長制約
  - **境界値選択の根拠**: 要件定義書（WRREQ-013, WREDGE-004）に記載された文字列長制約
  - **実際の使用場面**: カード名が100文字を超える場合、データベースレベルでエラーが発生する
- **期待される結果**: 
  - `name`フィールドに`@db.VarChar(100)`が設定されている
  - `description`フィールドに`@db.VarChar(1000)`が設定されている
  - `reactionEffect`フィールドに`@db.VarChar(500)`が設定されている
  - **境界での正確性**: 文字列長制約が正しく設定されていれば、データ整合性が保たれる
  - **一貫した動作**: すべての文字列フィールドで一貫した制約が設定されている
- **テストの目的**: 文字列長制約の正確性を確認
  - **堅牢性の確認**: 文字列長制約により、データの整合性が保たれる
- 🔵 **信頼性レベル: 青信号** - 要件定義書から直接導出

#### TC-010: 数値範囲制約の確認（CHECK制約）

- **テスト名**: 数値フィールドの範囲制約が正しく設定されていることを確認
  - **境界値の意味**: 数値フィールドの範囲制約が正しく設定されていれば、データ整合性が保たれる
  - **境界値での動作保証**: 範囲外の値がデータベースに保存されないことを保証する
- **入力値**: 要件定義書に記載された数値範囲制約
  - **境界値選択の根拠**: 要件定義書（WRREQ-013, WRREQ-014, WREDGE-005）に記載された数値範囲制約
  - **実際の使用場面**: `stabilityValue`が-100〜100の範囲外、または`energyCost`が0〜5の範囲外の場合、データベースレベルでエラーが発生する
- **期待される結果**: 
  - `stabilityValue`フィールドにCHECK制約が設定されている（-100〜100）
  - `energyCost`フィールドにCHECK制約が設定されている（0〜5）
  - **境界での正確性**: 数値範囲制約が正しく設定されていれば、データ整合性が保たれる
  - **一貫した動作**: すべての数値フィールドで一貫した制約が設定されている
- **テストの目的**: 数値範囲制約の正確性を確認
  - **堅牢性の確認**: 数値範囲制約により、データの整合性が保たれる
- 🔵 **信頼性レベル: 青信号** - 要件定義書から直接導出

**注意**: PrismaスキーマではCHECK制約を直接定義できないため、マイグレーションファイルでSQLのCHECK制約を追加する必要がある。このテストケースは、マイグレーションファイルの検証として実装する。

#### TC-011: NULL許容フィールドの確認

- **テスト名**: NULL許容フィールドが正しく定義されていることを確認
  - **境界値の意味**: NULL許容フィールドが正しく設定されていれば、オプショナルなデータを適切に扱える
  - **境界値での動作保証**: NULL値がデータベースに保存できることを保証する
- **入力値**: 要件定義書に記載されたNULL許容フィールド一覧
  - **境界値選択の根拠**: 要件定義書に記載されたオプショナルフィールド定義
  - **実際の使用場面**: オプショナルなデータ（画像URL、レア度など）がNULLとして保存される
- **期待される結果**: 
  - `reactionEffect`, `imageUrl`, `rarity`, `evolutionFromId`, `deletedAt`フィールドが`String?`または`DateTime?`型として定義されている（`?`マーカーが付いている）
  - 必須フィールド（`name`, `description`, `cardType`, `attribute`, `stabilityValue`, `energyCost`, `createdAt`, `updatedAt`）がNULL許容でない（`?`マーカーが付いていない）
  - **境界での正確性**: NULL許容フィールドが正しく設定されていれば、データの柔軟性が保たれる
  - **一貫した動作**: すべてのフィールドで一貫したNULL許容設定がされている
- **テストの目的**: NULL許容フィールドの正確性を確認
  - **堅牢性の確認**: NULL許容フィールドにより、データの柔軟性が保たれる
- 🔵 **信頼性レベル: 青信号** - 要件定義書から直接導出

#### TC-012: UNIQUE制約の確認

- **テスト名**: `name`フィールドにUNIQUE制約が正しく設定されていることを確認
  - **境界値の意味**: UNIQUE制約が正しく設定されていれば、データの一意性が保たれる
  - **境界値での動作保証**: 同名のカードがデータベースに保存されないことを保証する
- **入力値**: 要件定義書に記載されたUNIQUE制約定義
  - **境界値選択の根拠**: 要件定義書（WRREQ-020）に記載されたUNIQUE制約要件
  - **実際の使用場面**: 同名のカードを作成しようとした場合、データベースレベルでエラーが発生する
- **期待される結果**: 
  - `name`フィールドに`@unique`ディレクティブが設定されている
  - **境界での正確性**: UNIQUE制約が正しく設定されていれば、データの一意性が保たれる
  - **一貫した動作**: UNIQUE制約が一貫して適用されている
- **テストの目的**: UNIQUE制約の正確性を確認
  - **堅牢性の確認**: UNIQUE制約により、データの一意性が保たれる
- 🔵 **信頼性レベル: 青信号** - 要件定義書から直接導出

#### TC-013: FOREIGN KEY制約の確認

- **テスト名**: `evolutionFromId`フィールドにFOREIGN KEY制約が正しく設定されていることを確認
  - **境界値の意味**: FOREIGN KEY制約が正しく設定されていれば、参照整合性が保たれる
  - **境界値での動作保証**: 存在しないカードIDを参照できないことを保証する
- **入力値**: 要件定義書に記載されたFOREIGN KEY制約定義
  - **境界値選択の根拠**: 要件定義書（WRREQ-015）に記載されたFOREIGN KEY制約要件
  - **実際の使用場面**: 存在しないカードIDを`evolutionFromId`に指定した場合、データベースレベルでエラーが発生する
- **期待される結果**: 
  - `evolutionFromId`フィールドに`@relation`ディレクティブが設定されている
  - `onDelete: SetNull`が設定されている
  - `evolutionFrom`リレーションフィールドが定義されている
  - `evolutionTo`リレーションフィールドが定義されている
  - **境界での正確性**: FOREIGN KEY制約が正しく設定されていれば、参照整合性が保たれる
  - **一貫した動作**: FOREIGN KEY制約が一貫して適用されている
- **テストの目的**: FOREIGN KEY制約の正確性を確認
  - **堅牢性の確認**: FOREIGN KEY制約により、参照整合性が保たれる
- 🔵 **信頼性レベル: 青信号** - 要件定義書から直接導出

## テスト実装方針

### テストフレームワーク

🔵 **信頼性レベル: 青信号** - Prisma公式ドキュメントに基づく標準的な検証方法

- **Prisma CLI**: `prisma validate`コマンドを使用してスキーマの検証を行う
- **Prisma CLI**: `prisma generate`コマンドを使用してPrisma Clientの生成を確認する
- **手動検証**: Prismaスキーマファイルの内容を直接確認する

### テスト実行方法

1. **スキーマ検証**: `cd backend && npx prisma validate`
2. **Client生成**: `cd backend && npx prisma generate`
3. **型チェック**: `cd backend && npm run type-check`
4. **手動確認**: Prismaスキーマファイルの内容を要件定義書と照合

### テストデータ

- **テストデータ不要**: Prismaスキーマ定義のテストのため、テストデータは不要
- **検証対象**: Prismaスキーマファイル（`backend/prisma/schema.prisma`）の内容

## 品質判定

### テストケース分類

✅ **高品質**:
- テストケース分類: 正常系・異常系・境界値が網羅されている
- 期待値定義: 各テストケースの期待値が明確
- 技術選択: Prisma CLIを使用した標準的な検証方法
- 実装可能性: 現在の技術スタックで実現可能

### テストケース網羅性

- **正常系**: 6個のテストケース（TC-001〜TC-006）
- **異常系**: 2個のテストケース（TC-007〜TC-008）
- **境界値**: 5個のテストケース（TC-009〜TC-013）
- **合計**: 13個のテストケース

### 実装上の注意事項

1. **依存タスク**: TASK-0011でENUM型（CardType, Rarity）が定義されている必要がある
2. **CHECK制約**: PrismaスキーマではCHECK制約を直接定義できないため、マイグレーションファイルでSQLのCHECK制約を追加する必要がある
3. **テスト実行順序**: スキーマ検証 → Client生成 → 型チェックの順で実行する

---

**作成日**: 2025-01-XX  
**作成者**: AI Assistant  
**品質判定**: ✅ 高品質
- テストケース分類: 正常系・異常系・境界値が網羅されている
- 期待値定義: 各テストケースの期待値が明確
- 技術選択: Prisma CLIを使用した標準的な検証方法
- 実装可能性: 現在の技術スタックで実現可能

**次のお勧めステップ**: `/tsumiki:tdd-red` でRedフェーズ（失敗テスト作成）を開始します。

