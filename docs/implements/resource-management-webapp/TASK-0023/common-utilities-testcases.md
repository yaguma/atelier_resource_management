# TDDテストケース定義: 共通ユーティリティ関数

## 開発言語・フレームワーク

- **プログラミング言語**: TypeScript 5.0+
  - **言語選択の理由**: プロジェクトでTypeScriptを使用しているため
  - **テストに適した機能**: 型安全性、型ガード機能
- **テストフレームワーク**: Vitest（推奨）またはJest
  - **フレームワーク選択の理由**: プロジェクトの技術スタックに合わせる（デフォルトはVitest推奨）
  - **テスト実行環境**: Node.js 18+ LTS
- 🔴 この内容の信頼性レベル: 一般的なベストプラクティスに基づく推測

---

## 1. 日付フォーマット関数 (`src/utils/date.ts`) のテストケース

### 1.1 正常系テストケース

#### TC-DATE-001: formatDate関数の基本動作
- **テスト名**: formatDate関数が正しく日付をフォーマットできること
  - **何をテストするか**: Dateオブジェクトをデフォルトフォーマットでフォーマットする機能
  - **期待される動作**: 日付が "YYYY-MM-DD HH:mm:ss" 形式でフォーマットされる
- **入力値**: `new Date(2025, 0, 15, 10, 30, 45)` (2025年1月15日 10時30分45秒)
  - **入力データの意味**: 一般的な日時を表すDateオブジェクト
- **期待される結果**: `"2025-01-15 10:30:45"`
  - **期待結果の理由**: デフォルトフォーマット "YYYY-MM-DD HH:mm:ss" に従う
- **テストの目的**: 基本的な日付フォーマット機能の確認
  - **確認ポイント**: フォーマット文字列が正しく適用されること
- 🔴 このテストケースの信頼性レベル: 一般的な日付フォーマット機能のベストプラクティス

#### TC-DATE-002: formatDate関数のカスタムフォーマット
- **テスト名**: formatDate関数がカスタムフォーマット文字列に対応できること
  - **何をテストするか**: カスタムフォーマット文字列を指定してフォーマットする機能
  - **期待される動作**: 指定されたフォーマット文字列に従ってフォーマットされる
- **入力値**: 
  - `date: new Date(2025, 0, 15, 10, 30, 45)`
  - `format: "YYYY/MM/DD"`
  - **入力データの意味**: カスタムフォーマット文字列を指定
- **期待される結果**: `"2025/01/15"`
  - **期待結果の理由**: カスタムフォーマット "YYYY/MM/DD" に従う
- **テストの目的**: カスタムフォーマット機能の確認
  - **確認ポイント**: フォーマット文字列が正しく解釈されること
- 🔴 このテストケースの信頼性レベル: 一般的な日付フォーマット機能のベストプラクティス

#### TC-DATE-003: formatDateISO関数の基本動作
- **テスト名**: formatDateISO関数がISO 8601形式でフォーマットできること
  - **何をテストするか**: DateオブジェクトをISO 8601形式でフォーマットする機能
  - **期待される動作**: 日付がISO 8601形式（"YYYY-MM-DDTHH:mm:ss.sssZ"）でフォーマットされる
- **入力値**: `new Date(2025, 0, 15, 10, 30, 45)`
  - **入力データの意味**: 一般的な日時を表すDateオブジェクト
- **期待される結果**: ISO 8601形式の文字列（例: `"2025-01-15T10:30:45.000Z"`）
  - **期待結果の理由**: ISO 8601標準に従う
- **テストの目的**: ISO 8601形式フォーマット機能の確認
  - **確認ポイント**: ISO 8601標準に準拠していること
- 🔴 このテストケースの信頼性レベル: ISO 8601標準に基づく

#### TC-DATE-004: formatDateShort関数の基本動作
- **テスト名**: formatDateShort関数が短い形式でフォーマットできること
  - **何をテストするか**: Dateオブジェクトを短い形式（YYYY-MM-DD）でフォーマットする機能
  - **期待される動作**: 日付が "YYYY-MM-DD" 形式でフォーマットされる
- **入力値**: `new Date(2025, 0, 15, 10, 30, 45)`
  - **入力データの意味**: 一般的な日時を表すDateオブジェクト
- **期待される結果**: `"2025-01-15"`
  - **期待結果の理由**: 短い形式 "YYYY-MM-DD" に従う
- **テストの目的**: 短い形式フォーマット機能の確認
  - **確認ポイント**: 時刻部分が除外されること
- 🔴 このテストケースの信頼性レベル: 一般的な日付フォーマット機能のベストプラクティス

#### TC-DATE-005: 文字列形式の日付のフォーマット
- **テスト名**: 文字列形式の日付を正しくフォーマットできること
  - **何をテストするか**: 文字列形式の日付をDateオブジェクトに変換してフォーマットする機能
  - **期待される動作**: 文字列形式の日付が正しくパースされてフォーマットされる
- **入力値**: `"2025-01-15T10:30:45Z"`
  - **入力データの意味**: ISO 8601形式の日付文字列
- **期待される結果**: フォーマットされた日付文字列
  - **期待結果の理由**: 文字列が正しくDateオブジェクトに変換されること
- **テストの目的**: 文字列形式の日付入力への対応確認
  - **確認ポイント**: 文字列が正しくパースされること
- 🔴 このテストケースの信頼性レベル: 一般的な日付フォーマット機能のベストプラクティス

#### TC-DATE-006: 数値形式（タイムスタンプ）の日付のフォーマット
- **テスト名**: 数値形式（タイムスタンプ）の日付を正しくフォーマットできること
  - **何をテストするか**: 数値形式（タイムスタンプ）の日付をDateオブジェクトに変換してフォーマットする機能
  - **期待される動作**: タイムスタンプが正しくDateオブジェクトに変換されてフォーマットされる
- **入力値**: `1736934645000` (2025-01-15 10:30:45のタイムスタンプ)
  - **入力データの意味**: Unixタイムスタンプ（ミリ秒）
- **期待される結果**: フォーマットされた日付文字列
  - **期待結果の理由**: タイムスタンプが正しくDateオブジェクトに変換されること
- **テストの目的**: タイムスタンプ形式の日付入力への対応確認
  - **確認ポイント**: タイムスタンプが正しく変換されること
- 🔴 このテストケースの信頼性レベル: 一般的な日付フォーマット機能のベストプラクティス

### 1.2 異常系テストケース

#### TC-DATE-101: nullが渡された場合の処理
- **テスト名**: nullが渡された場合、適切にエラーを処理できること
  - **エラーケースの概要**: null値が渡された場合の処理
  - **エラー処理の重要性**: null値による実行時エラーを防ぐため
- **入力値**: `null`
  - **不正な理由**: nullは有効な日付ではない
  - **実際の発生シナリオ**: データベースから取得した日付がnullの場合
- **期待される結果**: エラーをスローするか、デフォルト値を返す
  - **エラーメッセージの内容**: わかりやすいエラーメッセージ
  - **システムの安全性**: システムがクラッシュしないこと
- **テストの目的**: null値のエラーハンドリングの確認
  - **品質保証の観点**: 堅牢性の向上
- 🔴 このテストケースの信頼性レベル: 一般的なエラーハンドリングのベストプラクティス

#### TC-DATE-102: undefinedが渡された場合の処理
- **テスト名**: undefinedが渡された場合、適切にエラーを処理できること
  - **エラーケースの概要**: undefined値が渡された場合の処理
  - **エラー処理の重要性**: undefined値による実行時エラーを防ぐため
- **入力値**: `undefined`
  - **不正な理由**: undefinedは有効な日付ではない
  - **実際の発生シナリオ**: オプショナルな日付フィールドが未定義の場合
- **期待される結果**: エラーをスローするか、デフォルト値を返す
  - **エラーメッセージの内容**: わかりやすいエラーメッセージ
  - **システムの安全性**: システムがクラッシュしないこと
- **テストの目的**: undefined値のエラーハンドリングの確認
  - **品質保証の観点**: 堅牢性の向上
- 🔴 このテストケースの信頼性レベル: 一般的なエラーハンドリングのベストプラクティス

#### TC-DATE-103: 無効な日付文字列が渡された場合の処理
- **テスト名**: 無効な日付文字列が渡された場合、適切にエラーを処理できること
  - **エラーケースの概要**: パースできない無効な日付文字列が渡された場合の処理
  - **エラー処理の重要性**: 無効な入力による実行時エラーを防ぐため
- **入力値**: `"invalid-date-string"`
  - **不正な理由**: パースできない文字列
  - **実際の発生シナリオ**: ユーザー入力や外部APIからの不正なデータ
- **期待される結果**: エラーをスローするか、デフォルト値を返す
  - **エラーメッセージの内容**: わかりやすいエラーメッセージ
  - **システムの安全性**: システムがクラッシュしないこと
- **テストの目的**: 無効な日付文字列のエラーハンドリングの確認
  - **品質保証の観点**: 堅牢性の向上
- 🔴 このテストケースの信頼性レベル: 一般的なエラーハンドリングのベストプラクティス

### 1.3 境界値テストケース

#### TC-DATE-201: 最小値（1970-01-01）のフォーマット
- **テスト名**: Unixエポック（1970-01-01）を正しくフォーマットできること
  - **境界値の意味**: Unixエポックはタイムスタンプの基準点
  - **境界値での動作保証**: 最小値でも正しくフォーマットされること
- **入力値**: `new Date(0)` (1970-01-01 00:00:00 UTC)
  - **境界値選択の根拠**: Unixエポック（タイムスタンプの最小値）
  - **実際の使用場面**: データベースのデフォルト値など
- **期待される結果**: 正しくフォーマットされた日付文字列
  - **境界での正確性**: 最小値でも正確にフォーマットされること
  - **一貫した動作**: 通常の日付と同じように処理されること
- **テストの目的**: 最小値での動作確認
  - **堅牢性の確認**: 極端な値でも安定動作するか
- 🔴 このテストケースの信頼性レベル: 一般的な境界値テストのベストプラクティス

#### TC-DATE-202: 最大値（2100年以降）のフォーマット
- **テスト名**: 将来の日付（2100年以降）を正しくフォーマットできること
  - **境界値の意味**: 将来の日付も正しく処理できること
  - **境界値での動作保証**: 最大値でも正しくフォーマットされること
- **入力値**: `new Date(2100, 0, 1)` (2100年1月1日)
  - **境界値選択の根拠**: 将来の日付の代表例
  - **実際の使用場面**: 将来の予約やスケジュール管理
- **期待される結果**: 正しくフォーマットされた日付文字列
  - **境界での正確性**: 最大値でも正確にフォーマットされること
  - **一貫した動作**: 通常の日付と同じように処理されること
- **テストの目的**: 最大値での動作確認
  - **堅牢性の確認**: 極端な値でも安定動作するか
- 🔴 このテストケースの信頼性レベル: 一般的な境界値テストのベストプラクティス

---

## 2. バリデーション関数 (`src/utils/validation.ts`) のテストケース

### 2.1 正常系テストケース

#### TC-VALID-001: isRequired関数の基本動作（有効な値）
- **テスト名**: isRequired関数が有効な値に対してtrueを返すこと
  - **何をテストするか**: 値が存在する場合にtrueを返す機能
  - **期待される動作**: 有効な値（空でない文字列、数値、オブジェクトなど）に対してtrueを返す
- **入力値**: `"test"`, `123`, `{}`, `[]`
  - **入力データの意味**: 様々な型の有効な値
- **期待される結果**: `true`
  - **期待結果の理由**: 値が存在するため
- **テストの目的**: 基本的な必須チェック機能の確認
  - **確認ポイント**: 様々な型の値が正しく判定されること
- 🔴 このテストケースの信頼性レベル: 一般的なバリデーション機能のベストプラクティス

#### TC-VALID-002: isRequired関数の基本動作（無効な値）
- **テスト名**: isRequired関数が無効な値に対してfalseを返すこと
  - **何をテストするか**: 値が存在しない場合にfalseを返す機能
  - **期待される動作**: 無効な値（null、undefined、空文字列など）に対してfalseを返す
- **入力値**: `null`, `undefined`, `""`
  - **入力データの意味**: 無効な値の代表例
- **期待される結果**: `false`
  - **期待結果の理由**: 値が存在しないため
- **テストの目的**: 基本的な必須チェック機能の確認
  - **確認ポイント**: 無効な値が正しく判定されること
- 🔴 このテストケースの信頼性レベル: 一般的なバリデーション機能のベストプラクティス

#### TC-VALID-003: isString関数の基本動作
- **テスト名**: isString関数が文字列型を正しく判定できること
  - **何をテストするか**: 値が文字列型であるかを判定する機能（型ガード）
  - **期待される動作**: 文字列に対してtrueを返し、それ以外に対してfalseを返す
- **入力値**: `"test"`, `123`, `null`, `undefined`, `{}`
  - **入力データの意味**: 様々な型の値
- **期待される結果**: 
  - `"test"` → `true`
  - その他 → `false`
  - **期待結果の理由**: 文字列型のみがtrueを返す
- **テストの目的**: 型ガード機能の確認
  - **確認ポイント**: TypeScriptの型ガードとして正しく動作すること
- 🔴 このテストケースの信頼性レベル: TypeScriptの型ガード機能に基づく

#### TC-VALID-004: isNumber関数の基本動作
- **テスト名**: isNumber関数が数値型を正しく判定できること
  - **何をテストするか**: 値が数値型であるかを判定する機能（型ガード）
  - **期待される動作**: 数値に対してtrueを返し、それ以外に対してfalseを返す
- **入力値**: `123`, `"123"`, `null`, `undefined`, `NaN`
  - **入力データの意味**: 様々な型の値
- **期待される結果**: 
  - `123` → `true`
  - `NaN` → `false` (NaNは数値型だが、有効な数値ではない)
  - その他 → `false`
  - **期待結果の理由**: 数値型のみがtrueを返す
- **テストの目的**: 型ガード機能の確認
  - **確認ポイント**: TypeScriptの型ガードとして正しく動作すること
- 🔴 このテストケースの信頼性レベル: TypeScriptの型ガード機能に基づく

#### TC-VALID-005: isEmail関数の基本動作（有効なメールアドレス）
- **テスト名**: isEmail関数が有効なメールアドレスを正しく判定できること
  - **何をテストするか**: 文字列が有効なメールアドレス形式であるかを判定する機能
  - **期待される動作**: 有効なメールアドレス形式に対してtrueを返す
- **入力値**: `"test@example.com"`, `"user.name@example.co.jp"`
  - **入力データの意味**: 有効なメールアドレス形式の例
- **期待される結果**: `true`
  - **期待結果の理由**: 有効なメールアドレス形式であるため
- **テストの目的**: メールアドレス形式チェック機能の確認
  - **確認ポイント**: 一般的なメールアドレス形式が正しく判定されること
- 🔴 このテストケースの信頼性レベル: 一般的なメールアドレス形式のベストプラクティス

#### TC-VALID-006: isEmail関数の基本動作（無効なメールアドレス）
- **テスト名**: isEmail関数が無効なメールアドレスを正しく判定できること
  - **何をテストするか**: 文字列が無効なメールアドレス形式であるかを判定する機能
  - **期待される動作**: 無効なメールアドレス形式に対してfalseを返す
- **入力値**: `"invalid-email"`, `"@example.com"`, `"test@"`, `"test@.com"`
  - **入力データの意味**: 無効なメールアドレス形式の例
- **期待される結果**: `false`
  - **期待結果の理由**: 無効なメールアドレス形式であるため
- **テストの目的**: メールアドレス形式チェック機能の確認
  - **確認ポイント**: 無効な形式が正しく判定されること
- 🔴 このテストケースの信頼性レベル: 一般的なメールアドレス形式のベストプラクティス

#### TC-VALID-007: isUUID関数の基本動作（有効なUUID）
- **テスト名**: isUUID関数が有効なUUIDを正しく判定できること
  - **何をテストするか**: 文字列が有効なUUID形式であるかを判定する機能
  - **期待される動作**: 有効なUUID形式に対してtrueを返す
- **入力値**: `"550e8400-e29b-41d4-a716-446655440000"` (UUID v4形式)
  - **入力データの意味**: 有効なUUID形式の例
- **期待される結果**: `true`
  - **期待結果の理由**: 有効なUUID形式であるため
- **テストの目的**: UUID形式チェック機能の確認
  - **確認ポイント**: UUID v4形式が正しく判定されること
- 🔴 このテストケースの信頼性レベル: UUID標準（RFC 4122）に基づく

#### TC-VALID-008: isUUID関数の基本動作（無効なUUID）
- **テスト名**: isUUID関数が無効なUUIDを正しく判定できること
  - **何をテストするか**: 文字列が無効なUUID形式であるかを判定する機能
  - **期待される動作**: 無効なUUID形式に対してfalseを返す
- **入力値**: `"invalid-uuid"`, `"550e8400-e29b-41d4-a716"`, `"550e8400e29b41d4a716446655440000"`
  - **入力データの意味**: 無効なUUID形式の例
- **期待される結果**: `false`
  - **期待結果の理由**: 無効なUUID形式であるため
- **テストの目的**: UUID形式チェック機能の確認
  - **確認ポイント**: 無効な形式が正しく判定されること
- 🔴 このテストケースの信頼性レベル: UUID標準（RFC 4122）に基づく

#### TC-VALID-009: isInRange関数の基本動作
- **テスト名**: isInRange関数が範囲チェックを正しく実行できること
  - **何をテストするか**: 数値が指定された範囲内にあるかを判定する機能
  - **期待される動作**: 範囲内の値に対してtrueを返し、範囲外の値に対してfalseを返す
- **入力値**: 
  - `value: 5, min: 0, max: 10` → `true`
  - `value: 15, min: 0, max: 10` → `false`
  - `value: 0, min: 0, max: 10` → `true` (境界値)
  - `value: 10, min: 0, max: 10` → `true` (境界値)
  - **入力データの意味**: 範囲内、範囲外、境界値の例
- **期待される結果**: 上記の通り
  - **期待結果の理由**: 範囲チェックが正しく動作するため
- **テストの目的**: 範囲チェック機能の確認
  - **確認ポイント**: 範囲内、範囲外、境界値が正しく判定されること
- 🔴 このテストケースの信頼性レベル: 一般的なバリデーション機能のベストプラクティス

#### TC-VALID-010: isMaxLength関数の基本動作
- **テスト名**: isMaxLength関数が最大文字数チェックを正しく実行できること
  - **何をテストするか**: 文字列が指定された最大文字数以下であるかを判定する機能
  - **期待される動作**: 最大文字数以下の文字列に対してtrueを返し、超過している文字列に対してfalseを返す
- **入力値**: 
  - `value: "test", maxLength: 10` → `true`
  - `value: "this is a very long string", maxLength: 10` → `false`
  - `value: "1234567890", maxLength: 10` → `true` (境界値)
  - **入力データの意味**: 最大文字数以下、超過、境界値の例
- **期待される結果**: 上記の通り
  - **期待結果の理由**: 最大文字数チェックが正しく動作するため
- **テストの目的**: 最大文字数チェック機能の確認
  - **確認ポイント**: 最大文字数以下、超過、境界値が正しく判定されること
- 🔴 このテストケースの信頼性レベル: 一般的なバリデーション機能のベストプラクティス

#### TC-VALID-011: isMinLength関数の基本動作
- **テスト名**: isMinLength関数が最小文字数チェックを正しく実行できること
  - **何をテストするか**: 文字列が指定された最小文字数以上であるかを判定する機能
  - **期待される動作**: 最小文字数以上の文字列に対してtrueを返し、未満の文字列に対してfalseを返す
- **入力値**: 
  - `value: "test", minLength: 3` → `true`
  - `value: "ab", minLength: 3` → `false`
  - `value: "abc", minLength: 3` → `true` (境界値)
  - **入力データの意味**: 最小文字数以上、未満、境界値の例
- **期待される結果**: 上記の通り
  - **期待結果の理由**: 最小文字数チェックが正しく動作するため
- **テストの目的**: 最小文字数チェック機能の確認
  - **確認ポイント**: 最小文字数以上、未満、境界値が正しく判定されること
- 🔴 このテストケースの信頼性レベル: 一般的なバリデーション機能のベストプラクティス

### 2.2 異常系テストケース

#### TC-VALID-101: 型エラーが発生した場合の処理
- **テスト名**: 型エラーが発生した場合、適切にエラーを処理できること
  - **エラーケースの概要**: 予期しない型の値が渡された場合の処理
  - **エラー処理の重要性**: 型エラーによる実行時エラーを防ぐため
- **入力値**: 様々な型の値（オブジェクト、配列、関数など）
  - **不正な理由**: 予期しない型の値
  - **実際の発生シナリオ**: 外部APIからの予期しないデータ形式
- **期待される結果**: 適切なエラーメッセージを返すか、falseを返す
  - **エラーメッセージの内容**: わかりやすいエラーメッセージ
  - **システムの安全性**: システムがクラッシュしないこと
- **テストの目的**: 型エラーのエラーハンドリングの確認
  - **品質保証の観点**: 堅牢性の向上
- 🔴 このテストケースの信頼性レベル: 一般的なエラーハンドリングのベストプラクティス

### 2.3 境界値テストケース

#### TC-VALID-201: 空文字列の処理
- **テスト名**: 空文字列が正しく処理されること
  - **境界値の意味**: 空文字列は文字列型だが、値が存在しない状態
  - **境界値での動作保証**: 空文字列が正しく判定されること
- **入力値**: `""`
  - **境界値選択の根拠**: 文字列型の最小値（長さ0）
  - **実際の使用場面**: ユーザー入力が空の場合
- **期待される結果**: 
  - `isRequired("")` → `false`
  - `isString("")` → `true`
  - `isMaxLength("", 10)` → `true`
  - `isMinLength("", 3)` → `false`
  - **境界での正確性**: 空文字列が正しく判定されること
  - **一貫した動作**: 各関数で一貫した動作が保証されること
- **テストの目的**: 空文字列での動作確認
  - **堅牢性の確認**: 空文字列でも安定動作するか
- 🔴 このテストケースの信頼性レベル: 一般的な境界値テストのベストプラクティス

#### TC-VALID-202: 非常に長い文字列の処理
- **テスト名**: 非常に長い文字列が正しく処理されること
  - **境界値の意味**: 非常に長い文字列はパフォーマンスに影響する可能性がある
  - **境界値での動作保証**: 長い文字列でも正しく判定されること
- **入力値**: `"a".repeat(10000)` (10000文字の文字列)
  - **境界値選択の根拠**: 実用的な最大文字数の代表例
  - **実際の使用場面**: 大量のテキストデータ
- **期待される結果**: 正しく判定されること
  - **境界での正確性**: 長い文字列でも正確に判定されること
  - **一貫した動作**: 通常の文字列と同じように処理されること
- **テストの目的**: 長い文字列での動作確認
  - **堅牢性の確認**: 長い文字列でも安定動作するか
- 🔴 このテストケースの信頼性レベル: 一般的な境界値テストのベストプラクティス

---

## 3. ログ出力関数 (`src/utils/logger.ts`) のテストケース

### 3.1 正常系テストケース

#### TC-LOG-001: logInfo関数の基本動作
- **テスト名**: logInfo関数が情報ログを正しく出力できること
  - **何をテストするか**: 情報レベルのログを出力する機能
  - **期待される動作**: コンソールに情報ログが出力される
- **入力値**: 
  - `message: "ユーザーがログインしました"`
  - `data: { userId: "123" }` (オプション)
  - **入力データの意味**: 一般的な情報ログの例
- **期待される結果**: コンソールに情報ログが出力される
  - **期待結果の理由**: 情報ログが正しく出力されるため
- **テストの目的**: 基本的な情報ログ出力機能の確認
  - **確認ポイント**: メッセージとデータが正しく出力されること
- 🔴 このテストケースの信頼性レベル: 一般的なログ出力機能のベストプラクティス

#### TC-LOG-002: logWarn関数の基本動作
- **テスト名**: logWarn関数が警告ログを正しく出力できること
  - **何をテストするか**: 警告レベルのログを出力する機能
  - **期待される動作**: コンソールに警告ログが出力される
- **入力値**: 
  - `message: "リクエストが遅延しています"`
  - `data: { duration: 5000 }` (オプション)
  - **入力データの意味**: 一般的な警告ログの例
- **期待される結果**: コンソールに警告ログが出力される
  - **期待結果の理由**: 警告ログが正しく出力されるため
- **テストの目的**: 基本的な警告ログ出力機能の確認
  - **確認ポイント**: メッセージとデータが正しく出力されること
- 🔴 このテストケースの信頼性レベル: 一般的なログ出力機能のベストプラクティス

#### TC-LOG-003: logError関数の基本動作
- **テスト名**: logError関数がエラーログを正しく出力できること
  - **何をテストするか**: エラーレベルのログを出力する機能
  - **期待される動作**: コンソールにエラーログが出力される
- **入力値**: 
  - `message: "データベース接続エラー"`
  - `error: new Error("Connection failed")` (オプション)
  - **入力データの意味**: 一般的なエラーログの例
- **期待される結果**: コンソールにエラーログが出力される
  - **期待結果の理由**: エラーログが正しく出力されるため
- **テストの目的**: 基本的なエラーログ出力機能の確認
  - **確認ポイント**: メッセージとエラーオブジェクトが正しく出力されること
- 🔴 このテストケースの信頼性レベル: 一般的なログ出力機能のベストプラクティス

#### TC-LOG-004: logDebug関数の基本動作
- **テスト名**: logDebug関数がデバッグログを正しく出力できること
  - **何をテストするか**: デバッグレベルのログを出力する機能
  - **期待される動作**: コンソールにデバッグログが出力される
- **入力値**: 
  - `message: "リクエストパラメータ"`
  - `data: { params: { id: "123" } }` (オプション)
  - **入力データの意味**: 一般的なデバッグログの例
- **期待される結果**: コンソールにデバッグログが出力される
  - **期待結果の理由**: デバッグログが正しく出力されるため
- **テストの目的**: 基本的なデバッグログ出力機能の確認
  - **確認ポイント**: メッセージとデータが正しく出力されること
- 🔴 このテストケースの信頼性レベル: 一般的なログ出力機能のベストプラクティス

### 3.2 異常系テストケース

#### TC-LOG-101: 長いメッセージの処理
- **テスト名**: 長いメッセージが正しく処理されること
  - **エラーケースの概要**: 非常に長いメッセージが渡された場合の処理
  - **エラー処理の重要性**: 長いメッセージによるパフォーマンス問題を防ぐため
- **入力値**: `message: "a".repeat(10000)` (10000文字のメッセージ)
  - **不正な理由**: 非常に長いメッセージ
  - **実際の発生シナリオ**: 大量のデータがメッセージに含まれる場合
- **期待される結果**: ログが正しく出力されるか、適切に切り詰められる
  - **エラーメッセージの内容**: なし（エラーをスローしない）
  - **システムの安全性**: システムがクラッシュしないこと
- **テストの目的**: 長いメッセージの処理確認
  - **品質保証の観点**: パフォーマンスと堅牢性の向上
- 🔴 このテストケースの信頼性レベル: 一般的なログ出力機能のベストプラクティス

#### TC-LOG-102: 循環参照を含むオブジェクトの処理
- **テスト名**: 循環参照を含むオブジェクトが正しく処理されること
  - **エラーケースの概要**: 循環参照を含むオブジェクトが渡された場合の処理
  - **エラー処理の重要性**: 循環参照による無限ループを防ぐため
- **入力値**: 
  ```typescript
  const obj: any = { name: "test" };
  obj.self = obj; // 循環参照
  ```
  - **不正な理由**: 循環参照を含むオブジェクト
  - **実際の発生シナリオ**: 複雑なデータ構造
- **期待される結果**: ログが正しく出力されるか、循環参照が適切に処理される
  - **エラーメッセージの内容**: なし（エラーをスローしない）
  - **システムの安全性**: システムがクラッシュしないこと
- **テストの目的**: 循環参照の処理確認
  - **品質保証の観点**: 堅牢性の向上
- 🔴 このテストケースの信頼性レベル: 一般的なログ出力機能のベストプラクティス

---

## テスト実装時の注意事項

### テスト実行環境
- Node.js 18+ LTS
- TypeScript 5.0+
- Vitest または Jest

### モック・スタブの使用
- ログ出力関数のテストでは、コンソール出力をモック化することを推奨
- 日付フォーマット関数のテストでは、固定の日付を使用してテストの再現性を確保

### テストカバレッジ目標
- 各関数のテストカバレッジ: 80%以上
- 正常系、異常系、境界値テストをすべてカバー

---

次のステップ: `/tdd-red` で失敗するテストを実装します。

